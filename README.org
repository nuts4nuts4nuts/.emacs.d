#+title: Emacs configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el :mkdirp yes

* Org file that makes an el file

Hello! This is an org-mode file that automatically generates an init.el file for emacs configuration. Cool, huh?

** Auto-tangle Configuration Files

This snippet adds a hook to =org-mode= buffers so that =dkj/org-babel-tangle-config= gets executed each time such a buffer gets saved.  This function checks to see if the file being saved is in my .emacs.d directory and, if so, automatically exports the configuration here to the associated output files.

#+begin_src emacs-lisp
  (defun dkj/org-babel-tangle-config ()
    "Automatically tangle our config.org config file when we save it"
    (when (string-equal (file-name-directory (buffer-file-name))
			(expand-file-name user-emacs-directory))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
	(org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'dkj/org-babel-tangle-config)))
#+end_src

** Personal customization
*** Settings

These are some basic settings to make life a little better. They don't relate to packages or anything fancy like that.

#+begin_src emacs-lisp
  ;; Turn off all the bars
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  ;; Except the tab bar ;)
  (tab-bar-mode 1)

  ;; Always prompt before exiting
  (defalias 'yes-or-no-p 'y-or-n-p)
  (setq confirm-kill-emacs 'y-or-n-p)

  ;; Turn off the beeping with visible-bell
  (setq visible-bell t)

  ;; command is a lot more ergonomic than option
  ;; also, less confusing when going back and forth between mac and windows
  (setq mac-command-modifier 'meta)

  ;; Allow the mouse in terminal mode
  (xterm-mouse-mode 1)

  ;; I can't see a god damn at this small font size
  (defun dkj/font-height (height)
    "Prompts the user for a height and sets the font height.
       Uses the prefix arg if one is provided."
    (interactive "NHeight: ")
    (set-face-attribute 'default nil :height height))
  (dkj/font-height 140)

  ;; Automatically set view-mode when in a readonly buffer
  ;; Set a buffer as readonly with C-x C-q
  (setq view-read-only t)

  ;; Use bar cursor since it matches the emacs model better
  (setq-default cursor-type 'bar)

  ;; Add more context when scrolling around
  (setq next-screen-context-lines 10)

  ;; Move to the top or bottom of the buffer when scrolling
  (setq scroll-error-top-bottom 1)

  ;; Bigger global mark ring
  (setq global-mark-ring-max 50)

  ;; Show column 80
  (setq fill-column 80)
  (global-display-fill-column-indicator-mode)

  ;; Prefer vertical splits in more cases
  (setq split-width-threshold 90)
  (setq split-height-threshold 100)

  ;; Backup to the ~/.emacs.d/backups directory
  (setq backup-directory-alist
	`(("." . ,(concat user-emacs-directory "backups"))))

  ;; When I send mail from emacs, open the default mail client (because I haven't set up sending mail from emacs yet).
  (setq send-mail-function 'mailclient-send-it)

  ;; Put the menu bar in the tab bar, to help with discoverability
  (defun dkj/tab-bar-format-menu-bar ()
    "Produce the Menu button (denoted as λ) for the tab bar that shows the menu bar."
    `((menu-bar menu-item (propertize "λ" 'face 'tab-bar-tab-inactive)
		tab-bar-menu-bar :help "Menu Bar")))
  (add-to-list 'tab-bar-format #'dkj/tab-bar-format-menu-bar)

  ;; Winner mode remembers my window layouts
  (winner-mode 1)

  ;; Save minibuffer history across sessions
  (savehist-mode 1)

  ;; Automatically pull changes to files from disk
  (global-auto-revert-mode 1)

  ;; Default to lax whitespace in isearch and match any char
  (setq search-whitespace-regexp ".*")
  (setq isearch-lax-whitespace t)
  (setq isearch-regexp-lax-whitespace nil)

  ;; Override disabled commands
  (put 'narrow-to-region 'disabled nil)

  ;; Enable recursive minibuffers
  (setq enable-recursive-minibuffers t)
#+end_src

*** Mappings

**** C-z as my personal keymap

By default, =C-c <letter>= is supposed to be reserved for user-defined commands.
This is not my favorite for a couple of reasons:
1. Some modes map =C-c <letter>= for some =<letter>= s
2. =C-c <letter>= is harder to press quickly than =C-c C-<letter>=, and =C-c C-<letter>= is explicitly reserved for modes to map.

So I want to make a own prefix, on which I can bind anything I like.
I've chosen =C-z= for this, since suspending Emacs is not something I intend on doing very often.

#+begin_src emacs-lisp
  (define-prefix-command 'dkj-keys)
  (global-set-key (kbd "C-z") #'dkj-keys)

  ;; Easily store links to org headers by id
  (define-key dkj-keys (kbd "C-l") #'org-id-store-link)
  ;; Capture something
  (define-key dkj-keys (kbd "C-c") #'org-capture)

  ;; Open the agenda
  (define-key dkj-keys (kbd "C-a") #'org-agenda)
#+end_src

**** Bunch of mappings

#+begin_src emacs-lisp
  ;; Reserve this for tmux. Previously toggle-input-method
  (global-unset-key (kbd "C-\\"))

  ;; Easier window movement
  (global-set-key (kbd "C-x C-1") #'delete-other-windows)
  (global-set-key (kbd "C-x C-2") #'split-window-below)
  (global-set-key (kbd "C-x C-3") #'split-window-right)
  (global-set-key (kbd "C-x C-0") #'delete-window)
  (global-set-key (kbd "C-x C-o") #'other-window)

  ;; Kill line backwards
  (global-set-key (kbd "M-<backspace>") (lambda () (interactive) (kill-line 0)))

  ;; Use dwim versions of upcase and downcase instead of char/word/region-specific verions
  (global-set-key (kbd "M-u") #'upcase-dwim)
  (global-set-key (kbd "M-l") #'downcase-dwim)

  ;; Use cycle-spacing since it replaces just-one-space,
  ;; delete-horizontal-space, and delete-blank-lines all in one
  (global-set-key (kbd "M-SPC") #'cycle-spacing)

  ;; Bind M-v to go from the completions buffer to the minibuffer,
  ;; mirroring the minubuffer binding to go to completions
  (define-key completion-list-mode-map (kbd "M-v") #'switch-to-minibuffer)

  ;; Bind M-/ to hippie-expand instead of dabbrev-expand, since hippie does the same but more
  (global-set-key (kbd "M-/") #'hippie-expand)
#+end_src

*** Functions

#+begin_src emacs-lisp
  ;; C-z C-h to open this file, my config
  (defun dkj/open-config ()
    "Open this file."
    (interactive)
    (push-mark)
    (find-file "~/.emacs.d/README.org"))
  (define-key dkj-keys (kbd "C-h") #'dkj/open-config)

  ;; Pulse for a little longer than the default
  (setq pulse-delay 0.1)
  ;; Pulse the line when I get lost
  (defun dkj/pulse-line (&rest _)
    "Pulse the current line."
    (pulse-momentary-highlight-one-line (point)))
  (dolist (command '(scroll-up-command scroll-down-command
				       recenter-top-bottom other-window))
    (advice-add command :after #'dkj/pulse-line))
#+end_src
 
** Org mode stuff

Org-mode is cool. That's an understatement, org-mode is one of the main reasons to use Emacs.

*** org-mode general settings

#+begin_src emacs-lisp
  (setq org-directory "~/org"
	org-default-notes-file "~/org/inbox.org"
	org-id-locations-file "~/org/.org-id-locations"
	org-startup-truncated nil
	org-ellipsis "↴")

  ;; Make inserting new list items a little cleaner
  (with-eval-after-load "org"
    (define-key org-mode-map (kbd "M-<return>") #'org-insert-item)
    (define-key org-mode-map (kbd "C-<return>") #'org-insert-heading))

  ;; Make the note template use an active timestamp
  (add-to-list 'org-log-note-headings
	       '(note . "Note taken on %T"))
#+end_src

*** Agenda settings
:PROPERTIES:
:ID:       C0A40428-DE44-44F5-8FA0-D01458CB2DBF
:END:

All flows from the agenda

#+begin_src emacs-lisp
  (defun dkj/present-agenda-and-clocked ()
    "Open the agenda and the currently clocked task side by side."
    (interactive)
    (progn
      (org-agenda nil "a")
      (delete-other-windows)
      (split-window-right)
      (other-window 1)
      (org-clock-goto)
      (recenter-top-bottom 0)))

  (defun dkj/open-agenda-main-view (prefix)
    "Open the main view of my agenda."
    (interactive "P")
    (progn
      (setq current-prefix-arg nil)
      (cond
       ((equal prefix '(4)) (dkj/present-agenda-and-clocked))
       ((equal major-mode 'org-agenda-mode) (progn
					      (delete-other-windows)
					      (org-agenda-redo-all)))
       (t (org-agenda nil "a")))))

  ;; Open the main view of the agenda with f12
  (global-set-key (kbd "<f12>") #'dkj/open-agenda-main-view)


  ;; ~/org for agenda and refile settings
  (setq org-agenda-files '("~/org")
	org-refile-targets '((nil :maxlevel . 9) (org-agenda-files :maxlevel . 9))
	org-outline-path-complete-in-steps nil
	org-refile-use-outline-path 'file
	org-agenda-span 'day)

  ;; Open my custom agenda view
  (setq org-agenda-custom-commands '(("n"
				      "Day agenda and all TODOs"
				      ((agenda #1="")
				       (alltodo #1#)))))

  ;; Agenda sorting order
  (setq org-agenda-sorting-strategy '((agenda time-up todo-state-down category-keep)
				      (todo todo-state-down category-keep)
				      (tags priority-down category-keep)
				      (search category-keep)))
  ;; Agenda clockreport settings
  (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 4 :tags t))

  (defun dkj/format-n-breadcrumbs (n)
    "Formats the top n headers for an org item for my agenda."
    (let* ((breadcrumbs (org-get-outline-path))
	   (first-n (seq-subseq breadcrumbs
				0
				(min n
				     (length breadcrumbs)))))
      (format "%-25.25s" (if first-n
			     (string-join first-n ">")
			   ""))))

  ;; Number of breadcrumbs to format into my agenda prefix
  (setq breadcrumbs-to-format 2)
  ;; Set prefix to use top level header instead of file name in todo list
  (setq org-agenda-prefix-format
	'((agenda . " %i %(dkj/format-n-breadcrumbs breadcrumbs-to-format) %?-12t% s")
	  (todo . " %i %(dkj/format-n-breadcrumbs breadcrumbs-to-format) ")
	  (tags . " %i %-12:c")
	  (search . " %i %-12:c")))

  ;; Remap h (org-agenda-holidays) to org-revert-all-org-buffers
  (with-eval-after-load "org"
    (define-key org-agenda-mode-map (kbd "h") #'org-revert-all-org-buffers))


#+end_src

*** Todo settings

#+begin_src emacs-lisp
  (setq org-todo-keywords
	'((sequence "TODO(t!)" "NEXT(n!)" "|" "DONE(d!)")
	  (sequence "|" "CANCELED(c!)")
	  (sequence "HABIT(h!)" "|" "DONE(d!)"))
	org-clock-into-drawer t
	org-log-into-drawer t)

  ;; Set :STYLE: habit for HABIT todos
  (defun dkj/org-set-habit ()
    (interactive)
    (when (equal (org-get-todo-state) "HABIT")
      (org-set-property "STYLE" "habit")))
  (add-hook 'org-after-todo-state-change-hook #'dkj/org-set-habit)
#+end_src

*** Capture templates

Quick cap

#+begin_src emacs-lisp
  (setq org-capture-templates
	(quote (("t" "Todo" entry (file "~/org/inbox.org")
		 "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
		("m" "Meeting" entry (file+datetree "~/org/meetings.org")
		 "* %? :MEETING:\n%U\n" :clock-in t :clock-resume t)
		("i" "Interrupt" entry (file+datetree "~/org/journal.org")
		 "* %? :INTERRUPT:\n%U\n" :clock-in t :clock-resume t)
		("j" "Journal" entry (file+datetree "~/org/journal.org")
		 "* %? :JOURNAL:\n%U\n" :clock-in t :clock-resume t))))
#+end_src

*** Clock settings

Use org-mode to clock time spent on things.
Estimate time before starting tasks.
Get better at estimation through iteration.
Etc...
Largely taken from / inspired by http://doc.norang.ca/org-mode.html#Clocking

#+begin_src emacs-lisp
  ;; Show lot of clocking history so it's easy to pick items off the C-z C-i list
  (setq org-clock-history-length 10)
  ;; Resume clocking task on clock-in if the clock is open
  (setq org-clock-in-resume t)
  ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
  (setq org-clock-out-remove-zero-time-clocks t)
  ;; Save the running clock and all clock history when exiting Emacs, load it on startup
  (setq org-clock-persist t)
  ;; Set clock duration format to never aggregate up to days
  (setq org-duration-format (quote h:mm))

  ;; Define things that show up as issues in clock check (v c in org-agenda)
  ;; Only thing I've changed is lowering the default max-gap from 5 minutes to 1
  ;; and lowering the default max-duration from 10 hours to 5 hours.
  (setq org-agenda-clock-consistency-checks '(:max-duration "5:00"
							    :min-duration 0
							    :max-gap "0:01"
							    :gap-ok-around
							    ("4:00")
							    :default-face
							    ((:background "DarkRed")
							     (:foreground "white"))
							    :overlap-face nil
							    :gap-face nil
							    :no-end-time-face nil
							    :long-face nil
							    :short-face nil))

  (defun dkj/global-clock-in ()
    (interactive)
    (org-clock-in '(4)))
  (define-key dkj-keys (kbd "C-i") #'dkj/global-clock-in)
#+end_src

*** Export defaults

The export options are detailed [[https://orgmode.org/manual/Export-Settings.html][here]].
Use defaults that make sense for me.

#+begin_src emacs-lisp
  (setq org-export-with-sub-superscripts nil
	org-export-with-section-numbers nil
	org-export-with-toc nil
	org-export-headline-levels 10)
#+end_src

*** Markdown export

Markdown is still useful, so we need a backend to export to it.

#+begin_src emacs-lisp
  (setq org-export-backends '(ascii html icalendar latex md odt))
#+end_src

*** Org execute other languages inline

With C-c C-c

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     (python . t)
     ))

  (setq org-babel-python-command "python3")
#+end_src

** Packages
*** Using packages

Packages are hip and cool and emacs is pretty good at using them.

#+begin_src emacs-lisp
  ;; Initialize package sources
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
			   ("org" . "https://orgmode.org/elpa/")
			   ("elpa" . "https://elpa.gnu.org/packages/")))
  (package-initialize)

  ;; Initialize use-package on non-Linux platforms
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (require 'use-package)
  (setq use-package-always-ensure t)
#+end_src

**** Automatic Package Updates

The auto-package-update package helps us keep our Emacs packages up to date!  It will prompt you after a certain number of days either at startup or at a specific time of day to remind you to update your packages.

You can also use =M-x auto-package-update-now= to update right now!

#+begin_src emacs-lisp
  (use-package auto-package-update
    :custom
    (auto-package-update-interval 7)
    (auto-package-update-prompt-before-update t)
    (auto-package-update-hide-results t)
    :config
    (auto-package-update-maybe)
    (auto-package-update-at-time "09:00"))
#+end_src

*** Which-key

[[https://github.com/justbur/emacs-which-key][which-key]] is a package which describes available key bindings interactively. If you use a binding which prefixes other bindings and then wait, it will pop up a small buffer with the available follow ups.

#+begin_src emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+end_src

*** Terminal fixes

**** term-keys

Terminal emacs is hell.
When we have to use it, [[https://github.com/CyberShadow/term-keys][term-keys]] helps.

#+begin_src emacs-lisp
  (when (not (display-graphic-p))
    (add-to-list 'package-archives
		 '("cselpa" . "https://elpa.thecybershadow.net/packages/"))
    (use-package term-keys
      :config
      (term-keys-mode t)))
#+end_src

**** Clipetty mode

[[https://github.com/spudlyo/clipetty][Clipetty]] is a minor mode that makes copying from terminal emacs and pasting in other applications work better.

#+begin_src emacs-lisp
  (when (not (display-graphic-p))
    (use-package clipetty
      :ensure t
      :hook (after-init . global-clipetty-mode)))
#+end_src

*** Pretty colors

#+begin_src emacs-lisp
  ;; Themes that I like to have available
  (use-package gruvbox-theme)
  (use-package material-theme)

  ;; Light and dark themes I'm using currently
  (setq dkj/theme-light 'modus-operandi)
  (setq dkj/theme-dark 'modus-vivendi)

  ;; Function to swap between light and dark theme
  (defun dkj/swap-themes ()
    (interactive)
    (let ((current-theme (car custom-enabled-themes)))
      (mapc #'disable-theme custom-enabled-themes)
      (load-theme (cond
		   ((eq current-theme dkj/theme-light) dkj/theme-dark)
		   ((eq current-theme dkj/theme-dark) dkj/theme-light))
		  t)))

  ;; Bind swapping between light and dark theme to "C-z C-\"
  (define-key dkj-keys (kbd "C-\\") #'dkj/swap-themes)

  ;; Default to dark theme
  (load-theme dkj/theme-dark t)
#+end_src

*** Dot-mode

~dot-mode~ gives us a function similar to Vim's ~.~, which replays the last sequence of edits.

#+begin_src emacs-lisp
  (use-package dot-mode
    :config
    (dot-mode 1)
    (global-dot-mode 1))

  ;; Remap the default dot-mode bindings to not conflict with my Embark bindings
  (with-eval-after-load "dot-mode"
    (define-key dot-mode-map (kbd "C-.") nil)
    (define-key dot-mode-map (kbd "C-M-.") nil)
    (define-key dot-mode-map (kbd "C-c .") nil)
    (define-key dot-mode-map (kbd "C-x C-z") #'dot-mode-execute)
    (define-key dot-mode-map (kbd "C-x C-M-z") #'dot-mode-override)
    (define-key dot-mode-map (kbd "C-z C-z") #'dot-mode-copy-to-last-kbd-macro))
#+end_src

*** Magit

[[https://github.com/magit/magit][Magit]] is a git frontend. People really like it. I'm used to fugitive. Anyway, this is Emacs, so we use Magit.

#+begin_src emacs-lisp
  (use-package magit)
#+end_src

*** Vertico

Vertico is a vertical completing-read interface. It's pretty much the same as fido-vertical-mode, which is built in now, but it's more performant.

#+begin_src emacs-lisp
  ;; Enable vertico
  (use-package vertico
    :init
    (vertico-mode)

    ;; Different scroll margin
    ;; (setq vertico-scroll-margin 0)

    ;; Show more candidates
    ;; (setq vertico-count 20)

    ;; Grow and shrink the Vertico minibuffer
    ;; (setq vertico-resize t)

    ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
    ;; (setq vertico-cycle t)
    )
#+end_src

*** Orderless

Orderless completion.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless initials basic)
	  completion-category-defaults nil
	  completion-category-overrides '((file (styles partial-completion)))))
#+end_src

*** Marginalia

[[https://github.com/minad/marginalia][Marginalia]] adds more context to minibuffer completions.

#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :config
    (marginalia-mode)
    :bind
    (:map minibuffer-local-map
	  ("M-A" . marginalia-cycle)))
#+end_src

*** Embark

[[https://github.com/oantolin/embark][Embark]] is a right-click menu for the keyboard.

#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    ;; Use the minimal indicator instead of the default mixed indicator
    (setq embark-indicators '(embark-minimal-indicator embark-highlight-indicator embark-isearch-highlight-indicator))
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
		 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
		   nil
		   (window-parameters (mode-line-format . none)))))
#+end_src

*** Language support

Packages for configuring support of various computer languages

**** Markdown

In emacs we want to mostly write [[Org mode stuff][org-mode]] when it comes to markup languages. Still, markdown is useful.

#+begin_src emacs-lisp
  (use-package markdown-mode)
#+end_src

**** Racket

[[https://www.racket-mode.com/][racket-mode]] is so good dude. I can't go back to vim.

#+begin_src emacs-lisp
  (use-package racket-mode)
#+end_src

**** Godot engine

GDScript mode!

#+begin_src emacs-lisp
  (use-package gdscript-mode)
#+end_src

** Load other files
I like to keep everything in one file, but sometimes stuff needs to go in other files for cleanliness or confidentiality.

#+begin_src emacs-lisp
  ;; Load customize stuff
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (when (file-exists-p custom-file)
    (load custom-file))

  ;; Load Google stuff if it exists
  (let ((googel (concat user-emacs-directory "google.el")))
    (when (file-exists-p googel)
      (load googel)))

  ;; Load non-Google stuff if it exists
  (let ((noogel (concat user-emacs-directory "noogle.el")))
    (when (file-exists-p noogel)
      (load noogel)))
#+end_src
